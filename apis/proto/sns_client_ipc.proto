// @file sns_client_ipc.proto
//
// @brief This file defines the data structures to enable communication between
// Qualcomm Sensing hub and its clients.
//
// @copyright
// Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
// SPDX-License-Identifier: BSD-3-Clause-Clear

syntax = "proto2";
import "nanopb.proto";
import "sns_client.proto";
import "sns_std_type.proto";

// @details Module providing a generic ipc defintion for connections to and from
// the framework.
//
// @startuml
// group Version Request
//   Client -> Sensinghub: client_ipc_msg ( sns_client_ipc_version_req )
//   Client <- Sensinghub: client_ipc_msg ( sns_client_ipc_version_resp )
// end
// ...
// group Connection Request
//   Client -> Sensinghub: client_ipc_msg ( sns_client_ipc_connect )
//   Client <- Sensinghub: client_ipc_msg ( sns_client_ipc_connect_ack )
// end
// ...
// group Request
//   Client -> Sensinghub: client_ipc_msg ( sns_client_ipc_req  )
//   Client <- Sensinghub: client_ipc_msg ( sns_client_ipc_resp  )
//   Client <- Sensinghub: client_ipc_msg ( sns_client_ipc_ind   )
// end
// ...
// group Disconnect Request
//   Client -> Sensinghub: client_ipc_msg ( sns_client_ipc_disconnect  )
// end
// @enduml
//


// @brief Connect message
// Client shall send "sns_client_ipc_connect" message to connect to the
// sensor service
message sns_client_ipc_connect {
   // Empty payload.
}

// @brief Connect acknowledgement message
// "sns_client_ipc_connect_ack" message is sent by the Sensor service
// in response to "sns_client_ipc_connect" message
message sns_client_ipc_connect_ack {

  // @brief Connection handle identifies the connection
  // "connection_handle" shall be non-zero when connection is successful
  // "connection_handle" shall be zero when connection is failed
  optional fixed32 connection_handle = 1;
}

// @brief Disconnect message
// Client shall send "sns_client_ipc_disconnect" message to disconnect the
// connection with Sensor service
message sns_client_ipc_disconnect {

  // @brief Connection handle identifies the connection
  optional fixed32 connection_handle = 1;
}

// @brief Request message
message sns_client_ipc_req {

  // @brief Connection handle identifies the connection
  optional fixed32 connection_handle = 1;

  // @brief Request message
  optional sns_client_request_msg request = 2;
}

// @brief Indication message
message sns_client_ipc_ind {
  // @brief Connection handle identifies the connection
  optional fixed32 connection_handle = 1;

  // @brief Event message
  optional sns_client_event_msg event = 2;
}

// @brief Response message
// @brief Response Message is sent in response to every request message
message sns_client_ipc_resp {

  // @brief Connection handle identifies the connection
  optional fixed32 connection_handle = 1;

  // @brief Error
  optional sns_std_error error = 2;
}

// @brief Version request message
message sns_client_ipc_version_req {

  // @brief Version request message
  optional sns_client_version_request_msg version_request = 1;
}

// @brief Version response message
// Version response message is sent in response to every version request 
// message
message sns_client_ipc_version_resp {

  // @brief Version response message
  optional sns_client_version_response_msg version_response = 1;
}

// @brief Top level message for all clients.
// If the Sensor Service receives a message type it does not understand, it will
// return a sns_client_ipc_resp with error code SNS_STD_ERROR_NOT_SUPPORTED
message sns_client_ipc_msg {
  oneof msg {
    // @brief messages "0x1 - 0x3F" are reserved for client to server messages
    sns_client_ipc_connect connect = 0x01;
    sns_client_ipc_disconnect disconnect = 0x02;
    sns_client_ipc_req req = 0x03;
    sns_client_ipc_version_req version_req = 0x04;

    // @brief messages "0x40 - 0x7F" are reserved for server to client messages
    sns_client_ipc_connect_ack connect_ack = 0x40;
    sns_client_ipc_resp resp = 0x41;
    sns_client_ipc_ind ind = 0x42;
    sns_client_ipc_version_resp version_resp = 0x43;
  }
}